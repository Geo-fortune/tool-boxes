// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: calibration.proto

#ifndef PROTOBUF_INCLUDED_calibration_2eproto
#define PROTOBUF_INCLUDED_calibration_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_calibration_2eproto 

namespace protobuf_calibration_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_calibration_2eproto
namespace calibration {
class CameraCalibParams;
class CameraCalibParamsDefaultTypeInternal;
extern CameraCalibParamsDefaultTypeInternal _CameraCalibParams_default_instance_;
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class LidarCalibParams;
class LidarCalibParamsDefaultTypeInternal;
extern LidarCalibParamsDefaultTypeInternal _LidarCalibParams_default_instance_;
class MarkerBoardParmas;
class MarkerBoardParmasDefaultTypeInternal;
extern MarkerBoardParmasDefaultTypeInternal _MarkerBoardParmas_default_instance_;
class RosbagParams;
class RosbagParamsDefaultTypeInternal;
extern RosbagParamsDefaultTypeInternal _RosbagParams_default_instance_;
}  // namespace calibration
namespace google {
namespace protobuf {
template<> ::calibration::CameraCalibParams* Arena::CreateMaybeMessage<::calibration::CameraCalibParams>(Arena*);
template<> ::calibration::Config* Arena::CreateMaybeMessage<::calibration::Config>(Arena*);
template<> ::calibration::LidarCalibParams* Arena::CreateMaybeMessage<::calibration::LidarCalibParams>(Arena*);
template<> ::calibration::MarkerBoardParmas* Arena::CreateMaybeMessage<::calibration::MarkerBoardParmas>(Arena*);
template<> ::calibration::RosbagParams* Arena::CreateMaybeMessage<::calibration::RosbagParams>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace calibration {

// ===================================================================

class Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calibration.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Config* other);
  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const final {
    return CreateMaybeMessage<Config>(NULL);
  }

  Config* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .calibration.RosbagParams rosbag_params = 2;
  bool has_rosbag_params() const;
  void clear_rosbag_params();
  static const int kRosbagParamsFieldNumber = 2;
  private:
  const ::calibration::RosbagParams& _internal_rosbag_params() const;
  public:
  const ::calibration::RosbagParams& rosbag_params() const;
  ::calibration::RosbagParams* release_rosbag_params();
  ::calibration::RosbagParams* mutable_rosbag_params();
  void set_allocated_rosbag_params(::calibration::RosbagParams* rosbag_params);

  // required .calibration.LidarCalibParams lidar_calib_params = 3;
  bool has_lidar_calib_params() const;
  void clear_lidar_calib_params();
  static const int kLidarCalibParamsFieldNumber = 3;
  private:
  const ::calibration::LidarCalibParams& _internal_lidar_calib_params() const;
  public:
  const ::calibration::LidarCalibParams& lidar_calib_params() const;
  ::calibration::LidarCalibParams* release_lidar_calib_params();
  ::calibration::LidarCalibParams* mutable_lidar_calib_params();
  void set_allocated_lidar_calib_params(::calibration::LidarCalibParams* lidar_calib_params);

  // required .calibration.CameraCalibParams camera_calib_params = 4;
  bool has_camera_calib_params() const;
  void clear_camera_calib_params();
  static const int kCameraCalibParamsFieldNumber = 4;
  private:
  const ::calibration::CameraCalibParams& _internal_camera_calib_params() const;
  public:
  const ::calibration::CameraCalibParams& camera_calib_params() const;
  ::calibration::CameraCalibParams* release_camera_calib_params();
  ::calibration::CameraCalibParams* mutable_camera_calib_params();
  void set_allocated_camera_calib_params(::calibration::CameraCalibParams* camera_calib_params);

  // required .calibration.MarkerBoardParmas marker_board_params = 5;
  bool has_marker_board_params() const;
  void clear_marker_board_params();
  static const int kMarkerBoardParamsFieldNumber = 5;
  private:
  const ::calibration::MarkerBoardParmas& _internal_marker_board_params() const;
  public:
  const ::calibration::MarkerBoardParmas& marker_board_params() const;
  ::calibration::MarkerBoardParmas* release_marker_board_params();
  ::calibration::MarkerBoardParmas* mutable_marker_board_params();
  void set_allocated_marker_board_params(::calibration::MarkerBoardParmas* marker_board_params);

  // required bool use_rosbag = 1;
  bool has_use_rosbag() const;
  void clear_use_rosbag();
  static const int kUseRosbagFieldNumber = 1;
  bool use_rosbag() const;
  void set_use_rosbag(bool value);

  // @@protoc_insertion_point(class_scope:calibration.Config)
 private:
  void set_has_use_rosbag();
  void clear_has_use_rosbag();
  void set_has_rosbag_params();
  void clear_has_rosbag_params();
  void set_has_lidar_calib_params();
  void clear_has_lidar_calib_params();
  void set_has_camera_calib_params();
  void clear_has_camera_calib_params();
  void set_has_marker_board_params();
  void clear_has_marker_board_params();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::calibration::RosbagParams* rosbag_params_;
  ::calibration::LidarCalibParams* lidar_calib_params_;
  ::calibration::CameraCalibParams* camera_calib_params_;
  ::calibration::MarkerBoardParmas* marker_board_params_;
  bool use_rosbag_;
  friend struct ::protobuf_calibration_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RosbagParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calibration.RosbagParams) */ {
 public:
  RosbagParams();
  virtual ~RosbagParams();

  RosbagParams(const RosbagParams& from);

  inline RosbagParams& operator=(const RosbagParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RosbagParams(RosbagParams&& from) noexcept
    : RosbagParams() {
    *this = ::std::move(from);
  }

  inline RosbagParams& operator=(RosbagParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RosbagParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RosbagParams* internal_default_instance() {
    return reinterpret_cast<const RosbagParams*>(
               &_RosbagParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RosbagParams* other);
  friend void swap(RosbagParams& a, RosbagParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RosbagParams* New() const final {
    return CreateMaybeMessage<RosbagParams>(NULL);
  }

  RosbagParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RosbagParams>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RosbagParams& from);
  void MergeFrom(const RosbagParams& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RosbagParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string bag_file = 1;
  bool has_bag_file() const;
  void clear_bag_file();
  static const int kBagFileFieldNumber = 1;
  const ::std::string& bag_file() const;
  void set_bag_file(const ::std::string& value);
  #if LANG_CXX11
  void set_bag_file(::std::string&& value);
  #endif
  void set_bag_file(const char* value);
  void set_bag_file(const char* value, size_t size);
  ::std::string* mutable_bag_file();
  ::std::string* release_bag_file();
  void set_allocated_bag_file(::std::string* bag_file);

  // required string save_pth = 2;
  bool has_save_pth() const;
  void clear_save_pth();
  static const int kSavePthFieldNumber = 2;
  const ::std::string& save_pth() const;
  void set_save_pth(const ::std::string& value);
  #if LANG_CXX11
  void set_save_pth(::std::string&& value);
  #endif
  void set_save_pth(const char* value);
  void set_save_pth(const char* value, size_t size);
  ::std::string* mutable_save_pth();
  ::std::string* release_save_pth();
  void set_allocated_save_pth(::std::string* save_pth);

  // required string image_topic = 3;
  bool has_image_topic() const;
  void clear_image_topic();
  static const int kImageTopicFieldNumber = 3;
  const ::std::string& image_topic() const;
  void set_image_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_image_topic(::std::string&& value);
  #endif
  void set_image_topic(const char* value);
  void set_image_topic(const char* value, size_t size);
  ::std::string* mutable_image_topic();
  ::std::string* release_image_topic();
  void set_allocated_image_topic(::std::string* image_topic);

  // required string cloud_topic = 4;
  bool has_cloud_topic() const;
  void clear_cloud_topic();
  static const int kCloudTopicFieldNumber = 4;
  const ::std::string& cloud_topic() const;
  void set_cloud_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_cloud_topic(::std::string&& value);
  #endif
  void set_cloud_topic(const char* value);
  void set_cloud_topic(const char* value, size_t size);
  ::std::string* mutable_cloud_topic();
  ::std::string* release_cloud_topic();
  void set_allocated_cloud_topic(::std::string* cloud_topic);

  // @@protoc_insertion_point(class_scope:calibration.RosbagParams)
 private:
  void set_has_bag_file();
  void clear_has_bag_file();
  void set_has_save_pth();
  void clear_has_save_pth();
  void set_has_image_topic();
  void clear_has_image_topic();
  void set_has_cloud_topic();
  void clear_has_cloud_topic();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bag_file_;
  ::google::protobuf::internal::ArenaStringPtr save_pth_;
  ::google::protobuf::internal::ArenaStringPtr image_topic_;
  ::google::protobuf::internal::ArenaStringPtr cloud_topic_;
  friend struct ::protobuf_calibration_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LidarCalibParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calibration.LidarCalibParams) */ {
 public:
  LidarCalibParams();
  virtual ~LidarCalibParams();

  LidarCalibParams(const LidarCalibParams& from);

  inline LidarCalibParams& operator=(const LidarCalibParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LidarCalibParams(LidarCalibParams&& from) noexcept
    : LidarCalibParams() {
    *this = ::std::move(from);
  }

  inline LidarCalibParams& operator=(LidarCalibParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LidarCalibParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LidarCalibParams* internal_default_instance() {
    return reinterpret_cast<const LidarCalibParams*>(
               &_LidarCalibParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LidarCalibParams* other);
  friend void swap(LidarCalibParams& a, LidarCalibParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LidarCalibParams* New() const final {
    return CreateMaybeMessage<LidarCalibParams>(NULL);
  }

  LidarCalibParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LidarCalibParams>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LidarCalibParams& from);
  void MergeFrom(const LidarCalibParams& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LidarCalibParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 image_size = 1;
  int image_size_size() const;
  void clear_image_size();
  static const int kImageSizeFieldNumber = 1;
  ::google::protobuf::int32 image_size(int index) const;
  void set_image_size(int index, ::google::protobuf::int32 value);
  void add_image_size(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      image_size() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_image_size();

  // repeated float xyz_range = 2;
  int xyz_range_size() const;
  void clear_xyz_range();
  static const int kXyzRangeFieldNumber = 2;
  float xyz_range(int index) const;
  void set_xyz_range(int index, float value);
  void add_xyz_range(float value);
  const ::google::protobuf::RepeatedField< float >&
      xyz_range() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_xyz_range();

  // repeated float project_matrix = 6;
  int project_matrix_size() const;
  void clear_project_matrix();
  static const int kProjectMatrixFieldNumber = 6;
  float project_matrix(int index) const;
  void set_project_matrix(int index, float value);
  void add_project_matrix(float value);
  const ::google::protobuf::RepeatedField< float >&
      project_matrix() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_project_matrix();

  // repeated float lidar_init_rot = 8;
  int lidar_init_rot_size() const;
  void clear_lidar_init_rot();
  static const int kLidarInitRotFieldNumber = 8;
  float lidar_init_rot(int index) const;
  void set_lidar_init_rot(int index, float value);
  void add_lidar_init_rot(float value);
  const ::google::protobuf::RepeatedField< float >&
      lidar_init_rot() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_lidar_init_rot();

  // repeated float lidar_origin = 9;
  int lidar_origin_size() const;
  void clear_lidar_origin();
  static const int kLidarOriginFieldNumber = 9;
  float lidar_origin(int index) const;
  void set_lidar_origin(int index, float value);
  void add_lidar_origin(float value);
  const ::google::protobuf::RepeatedField< float >&
      lidar_origin() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_lidar_origin();

  // required float intensity_threshold = 3;
  bool has_intensity_threshold() const;
  void clear_intensity_threshold();
  static const int kIntensityThresholdFieldNumber = 3;
  float intensity_threshold() const;
  void set_intensity_threshold(float value);

  // required int32 marker_count = 4;
  bool has_marker_count() const;
  void clear_marker_count();
  static const int kMarkerCountFieldNumber = 4;
  ::google::protobuf::int32 marker_count() const;
  void set_marker_count(::google::protobuf::int32 value);

  // required bool use_camera_info = 5;
  bool has_use_camera_info() const;
  void clear_use_camera_info();
  static const int kUseCameraInfoFieldNumber = 5;
  bool use_camera_info() const;
  void set_use_camera_info(bool value);

  // required int32 iteration_count = 7;
  bool has_iteration_count() const;
  void clear_iteration_count();
  static const int kIterationCountFieldNumber = 7;
  ::google::protobuf::int32 iteration_count() const;
  void set_iteration_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:calibration.LidarCalibParams)
 private:
  void set_has_intensity_threshold();
  void clear_has_intensity_threshold();
  void set_has_marker_count();
  void clear_has_marker_count();
  void set_has_use_camera_info();
  void clear_has_use_camera_info();
  void set_has_iteration_count();
  void clear_has_iteration_count();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > image_size_;
  ::google::protobuf::RepeatedField< float > xyz_range_;
  ::google::protobuf::RepeatedField< float > project_matrix_;
  ::google::protobuf::RepeatedField< float > lidar_init_rot_;
  ::google::protobuf::RepeatedField< float > lidar_origin_;
  float intensity_threshold_;
  ::google::protobuf::int32 marker_count_;
  bool use_camera_info_;
  ::google::protobuf::int32 iteration_count_;
  friend struct ::protobuf_calibration_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CameraCalibParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calibration.CameraCalibParams) */ {
 public:
  CameraCalibParams();
  virtual ~CameraCalibParams();

  CameraCalibParams(const CameraCalibParams& from);

  inline CameraCalibParams& operator=(const CameraCalibParams& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraCalibParams(CameraCalibParams&& from) noexcept
    : CameraCalibParams() {
    *this = ::std::move(from);
  }

  inline CameraCalibParams& operator=(CameraCalibParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraCalibParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraCalibParams* internal_default_instance() {
    return reinterpret_cast<const CameraCalibParams*>(
               &_CameraCalibParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CameraCalibParams* other);
  friend void swap(CameraCalibParams& a, CameraCalibParams& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraCalibParams* New() const final {
    return CreateMaybeMessage<CameraCalibParams>(NULL);
  }

  CameraCalibParams* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CameraCalibParams>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CameraCalibParams& from);
  void MergeFrom(const CameraCalibParams& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraCalibParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string camera_config_path = 1;
  bool has_camera_config_path() const;
  void clear_camera_config_path();
  static const int kCameraConfigPathFieldNumber = 1;
  const ::std::string& camera_config_path() const;
  void set_camera_config_path(const ::std::string& value);
  #if LANG_CXX11
  void set_camera_config_path(::std::string&& value);
  #endif
  void set_camera_config_path(const char* value);
  void set_camera_config_path(const char* value, size_t size);
  ::std::string* mutable_camera_config_path();
  ::std::string* release_camera_config_path();
  void set_allocated_camera_config_path(::std::string* camera_config_path);

  // @@protoc_insertion_point(class_scope:calibration.CameraCalibParams)
 private:
  void set_has_camera_config_path();
  void clear_has_camera_config_path();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr camera_config_path_;
  friend struct ::protobuf_calibration_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarkerBoardParmas : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:calibration.MarkerBoardParmas) */ {
 public:
  MarkerBoardParmas();
  virtual ~MarkerBoardParmas();

  MarkerBoardParmas(const MarkerBoardParmas& from);

  inline MarkerBoardParmas& operator=(const MarkerBoardParmas& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarkerBoardParmas(MarkerBoardParmas&& from) noexcept
    : MarkerBoardParmas() {
    *this = ::std::move(from);
  }

  inline MarkerBoardParmas& operator=(MarkerBoardParmas&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarkerBoardParmas& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarkerBoardParmas* internal_default_instance() {
    return reinterpret_cast<const MarkerBoardParmas*>(
               &_MarkerBoardParmas_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MarkerBoardParmas* other);
  friend void swap(MarkerBoardParmas& a, MarkerBoardParmas& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarkerBoardParmas* New() const final {
    return CreateMaybeMessage<MarkerBoardParmas>(NULL);
  }

  MarkerBoardParmas* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarkerBoardParmas>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarkerBoardParmas& from);
  void MergeFrom(const MarkerBoardParmas& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkerBoardParmas* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 marker_number = 1;
  bool has_marker_number() const;
  void clear_marker_number();
  static const int kMarkerNumberFieldNumber = 1;
  ::google::protobuf::int32 marker_number() const;
  void set_marker_number(::google::protobuf::int32 value);

  // required float board_length_e1 = 2;
  bool has_board_length_e1() const;
  void clear_board_length_e1();
  static const int kBoardLengthE1FieldNumber = 2;
  float board_length_e1() const;
  void set_board_length_e1(float value);

  // required float board_length_e2 = 3;
  bool has_board_length_e2() const;
  void clear_board_length_e2();
  static const int kBoardLengthE2FieldNumber = 3;
  float board_length_e2() const;
  void set_board_length_e2(float value);

  // required float board_length_b1 = 4;
  bool has_board_length_b1() const;
  void clear_board_length_b1();
  static const int kBoardLengthB1FieldNumber = 4;
  float board_length_b1() const;
  void set_board_length_b1(float value);

  // required float board_length_b2 = 5;
  bool has_board_length_b2() const;
  void clear_board_length_b2();
  static const int kBoardLengthB2FieldNumber = 5;
  float board_length_b2() const;
  void set_board_length_b2(float value);

  // required float marker_length = 6;
  bool has_marker_length() const;
  void clear_marker_length();
  static const int kMarkerLengthFieldNumber = 6;
  float marker_length() const;
  void set_marker_length(float value);

  // @@protoc_insertion_point(class_scope:calibration.MarkerBoardParmas)
 private:
  void set_has_marker_number();
  void clear_has_marker_number();
  void set_has_board_length_e1();
  void clear_has_board_length_e1();
  void set_has_board_length_e2();
  void clear_has_board_length_e2();
  void set_has_board_length_b1();
  void clear_has_board_length_b1();
  void set_has_board_length_b2();
  void clear_has_board_length_b2();
  void set_has_marker_length();
  void clear_has_marker_length();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 marker_number_;
  float board_length_e1_;
  float board_length_e2_;
  float board_length_b1_;
  float board_length_b2_;
  float marker_length_;
  friend struct ::protobuf_calibration_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Config

// required bool use_rosbag = 1;
inline bool Config::has_use_rosbag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Config::set_has_use_rosbag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Config::clear_has_use_rosbag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Config::clear_use_rosbag() {
  use_rosbag_ = false;
  clear_has_use_rosbag();
}
inline bool Config::use_rosbag() const {
  // @@protoc_insertion_point(field_get:calibration.Config.use_rosbag)
  return use_rosbag_;
}
inline void Config::set_use_rosbag(bool value) {
  set_has_use_rosbag();
  use_rosbag_ = value;
  // @@protoc_insertion_point(field_set:calibration.Config.use_rosbag)
}

// required .calibration.RosbagParams rosbag_params = 2;
inline bool Config::has_rosbag_params() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config::set_has_rosbag_params() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config::clear_has_rosbag_params() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config::clear_rosbag_params() {
  if (rosbag_params_ != NULL) rosbag_params_->Clear();
  clear_has_rosbag_params();
}
inline const ::calibration::RosbagParams& Config::_internal_rosbag_params() const {
  return *rosbag_params_;
}
inline const ::calibration::RosbagParams& Config::rosbag_params() const {
  const ::calibration::RosbagParams* p = rosbag_params_;
  // @@protoc_insertion_point(field_get:calibration.Config.rosbag_params)
  return p != NULL ? *p : *reinterpret_cast<const ::calibration::RosbagParams*>(
      &::calibration::_RosbagParams_default_instance_);
}
inline ::calibration::RosbagParams* Config::release_rosbag_params() {
  // @@protoc_insertion_point(field_release:calibration.Config.rosbag_params)
  clear_has_rosbag_params();
  ::calibration::RosbagParams* temp = rosbag_params_;
  rosbag_params_ = NULL;
  return temp;
}
inline ::calibration::RosbagParams* Config::mutable_rosbag_params() {
  set_has_rosbag_params();
  if (rosbag_params_ == NULL) {
    auto* p = CreateMaybeMessage<::calibration::RosbagParams>(GetArenaNoVirtual());
    rosbag_params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calibration.Config.rosbag_params)
  return rosbag_params_;
}
inline void Config::set_allocated_rosbag_params(::calibration::RosbagParams* rosbag_params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rosbag_params_;
  }
  if (rosbag_params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rosbag_params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rosbag_params, submessage_arena);
    }
    set_has_rosbag_params();
  } else {
    clear_has_rosbag_params();
  }
  rosbag_params_ = rosbag_params;
  // @@protoc_insertion_point(field_set_allocated:calibration.Config.rosbag_params)
}

// required .calibration.LidarCalibParams lidar_calib_params = 3;
inline bool Config::has_lidar_calib_params() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Config::set_has_lidar_calib_params() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Config::clear_has_lidar_calib_params() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Config::clear_lidar_calib_params() {
  if (lidar_calib_params_ != NULL) lidar_calib_params_->Clear();
  clear_has_lidar_calib_params();
}
inline const ::calibration::LidarCalibParams& Config::_internal_lidar_calib_params() const {
  return *lidar_calib_params_;
}
inline const ::calibration::LidarCalibParams& Config::lidar_calib_params() const {
  const ::calibration::LidarCalibParams* p = lidar_calib_params_;
  // @@protoc_insertion_point(field_get:calibration.Config.lidar_calib_params)
  return p != NULL ? *p : *reinterpret_cast<const ::calibration::LidarCalibParams*>(
      &::calibration::_LidarCalibParams_default_instance_);
}
inline ::calibration::LidarCalibParams* Config::release_lidar_calib_params() {
  // @@protoc_insertion_point(field_release:calibration.Config.lidar_calib_params)
  clear_has_lidar_calib_params();
  ::calibration::LidarCalibParams* temp = lidar_calib_params_;
  lidar_calib_params_ = NULL;
  return temp;
}
inline ::calibration::LidarCalibParams* Config::mutable_lidar_calib_params() {
  set_has_lidar_calib_params();
  if (lidar_calib_params_ == NULL) {
    auto* p = CreateMaybeMessage<::calibration::LidarCalibParams>(GetArenaNoVirtual());
    lidar_calib_params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calibration.Config.lidar_calib_params)
  return lidar_calib_params_;
}
inline void Config::set_allocated_lidar_calib_params(::calibration::LidarCalibParams* lidar_calib_params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lidar_calib_params_;
  }
  if (lidar_calib_params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lidar_calib_params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lidar_calib_params, submessage_arena);
    }
    set_has_lidar_calib_params();
  } else {
    clear_has_lidar_calib_params();
  }
  lidar_calib_params_ = lidar_calib_params;
  // @@protoc_insertion_point(field_set_allocated:calibration.Config.lidar_calib_params)
}

// required .calibration.CameraCalibParams camera_calib_params = 4;
inline bool Config::has_camera_calib_params() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Config::set_has_camera_calib_params() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Config::clear_has_camera_calib_params() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Config::clear_camera_calib_params() {
  if (camera_calib_params_ != NULL) camera_calib_params_->Clear();
  clear_has_camera_calib_params();
}
inline const ::calibration::CameraCalibParams& Config::_internal_camera_calib_params() const {
  return *camera_calib_params_;
}
inline const ::calibration::CameraCalibParams& Config::camera_calib_params() const {
  const ::calibration::CameraCalibParams* p = camera_calib_params_;
  // @@protoc_insertion_point(field_get:calibration.Config.camera_calib_params)
  return p != NULL ? *p : *reinterpret_cast<const ::calibration::CameraCalibParams*>(
      &::calibration::_CameraCalibParams_default_instance_);
}
inline ::calibration::CameraCalibParams* Config::release_camera_calib_params() {
  // @@protoc_insertion_point(field_release:calibration.Config.camera_calib_params)
  clear_has_camera_calib_params();
  ::calibration::CameraCalibParams* temp = camera_calib_params_;
  camera_calib_params_ = NULL;
  return temp;
}
inline ::calibration::CameraCalibParams* Config::mutable_camera_calib_params() {
  set_has_camera_calib_params();
  if (camera_calib_params_ == NULL) {
    auto* p = CreateMaybeMessage<::calibration::CameraCalibParams>(GetArenaNoVirtual());
    camera_calib_params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calibration.Config.camera_calib_params)
  return camera_calib_params_;
}
inline void Config::set_allocated_camera_calib_params(::calibration::CameraCalibParams* camera_calib_params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete camera_calib_params_;
  }
  if (camera_calib_params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      camera_calib_params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, camera_calib_params, submessage_arena);
    }
    set_has_camera_calib_params();
  } else {
    clear_has_camera_calib_params();
  }
  camera_calib_params_ = camera_calib_params;
  // @@protoc_insertion_point(field_set_allocated:calibration.Config.camera_calib_params)
}

// required .calibration.MarkerBoardParmas marker_board_params = 5;
inline bool Config::has_marker_board_params() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Config::set_has_marker_board_params() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Config::clear_has_marker_board_params() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Config::clear_marker_board_params() {
  if (marker_board_params_ != NULL) marker_board_params_->Clear();
  clear_has_marker_board_params();
}
inline const ::calibration::MarkerBoardParmas& Config::_internal_marker_board_params() const {
  return *marker_board_params_;
}
inline const ::calibration::MarkerBoardParmas& Config::marker_board_params() const {
  const ::calibration::MarkerBoardParmas* p = marker_board_params_;
  // @@protoc_insertion_point(field_get:calibration.Config.marker_board_params)
  return p != NULL ? *p : *reinterpret_cast<const ::calibration::MarkerBoardParmas*>(
      &::calibration::_MarkerBoardParmas_default_instance_);
}
inline ::calibration::MarkerBoardParmas* Config::release_marker_board_params() {
  // @@protoc_insertion_point(field_release:calibration.Config.marker_board_params)
  clear_has_marker_board_params();
  ::calibration::MarkerBoardParmas* temp = marker_board_params_;
  marker_board_params_ = NULL;
  return temp;
}
inline ::calibration::MarkerBoardParmas* Config::mutable_marker_board_params() {
  set_has_marker_board_params();
  if (marker_board_params_ == NULL) {
    auto* p = CreateMaybeMessage<::calibration::MarkerBoardParmas>(GetArenaNoVirtual());
    marker_board_params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:calibration.Config.marker_board_params)
  return marker_board_params_;
}
inline void Config::set_allocated_marker_board_params(::calibration::MarkerBoardParmas* marker_board_params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete marker_board_params_;
  }
  if (marker_board_params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      marker_board_params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, marker_board_params, submessage_arena);
    }
    set_has_marker_board_params();
  } else {
    clear_has_marker_board_params();
  }
  marker_board_params_ = marker_board_params;
  // @@protoc_insertion_point(field_set_allocated:calibration.Config.marker_board_params)
}

// -------------------------------------------------------------------

// RosbagParams

// required string bag_file = 1;
inline bool RosbagParams::has_bag_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RosbagParams::set_has_bag_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RosbagParams::clear_has_bag_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RosbagParams::clear_bag_file() {
  bag_file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bag_file();
}
inline const ::std::string& RosbagParams::bag_file() const {
  // @@protoc_insertion_point(field_get:calibration.RosbagParams.bag_file)
  return bag_file_.GetNoArena();
}
inline void RosbagParams::set_bag_file(const ::std::string& value) {
  set_has_bag_file();
  bag_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calibration.RosbagParams.bag_file)
}
#if LANG_CXX11
inline void RosbagParams::set_bag_file(::std::string&& value) {
  set_has_bag_file();
  bag_file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calibration.RosbagParams.bag_file)
}
#endif
inline void RosbagParams::set_bag_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bag_file();
  bag_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calibration.RosbagParams.bag_file)
}
inline void RosbagParams::set_bag_file(const char* value, size_t size) {
  set_has_bag_file();
  bag_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calibration.RosbagParams.bag_file)
}
inline ::std::string* RosbagParams::mutable_bag_file() {
  set_has_bag_file();
  // @@protoc_insertion_point(field_mutable:calibration.RosbagParams.bag_file)
  return bag_file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RosbagParams::release_bag_file() {
  // @@protoc_insertion_point(field_release:calibration.RosbagParams.bag_file)
  if (!has_bag_file()) {
    return NULL;
  }
  clear_has_bag_file();
  return bag_file_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RosbagParams::set_allocated_bag_file(::std::string* bag_file) {
  if (bag_file != NULL) {
    set_has_bag_file();
  } else {
    clear_has_bag_file();
  }
  bag_file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bag_file);
  // @@protoc_insertion_point(field_set_allocated:calibration.RosbagParams.bag_file)
}

// required string save_pth = 2;
inline bool RosbagParams::has_save_pth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RosbagParams::set_has_save_pth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RosbagParams::clear_has_save_pth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RosbagParams::clear_save_pth() {
  save_pth_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_save_pth();
}
inline const ::std::string& RosbagParams::save_pth() const {
  // @@protoc_insertion_point(field_get:calibration.RosbagParams.save_pth)
  return save_pth_.GetNoArena();
}
inline void RosbagParams::set_save_pth(const ::std::string& value) {
  set_has_save_pth();
  save_pth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calibration.RosbagParams.save_pth)
}
#if LANG_CXX11
inline void RosbagParams::set_save_pth(::std::string&& value) {
  set_has_save_pth();
  save_pth_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calibration.RosbagParams.save_pth)
}
#endif
inline void RosbagParams::set_save_pth(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_save_pth();
  save_pth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calibration.RosbagParams.save_pth)
}
inline void RosbagParams::set_save_pth(const char* value, size_t size) {
  set_has_save_pth();
  save_pth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calibration.RosbagParams.save_pth)
}
inline ::std::string* RosbagParams::mutable_save_pth() {
  set_has_save_pth();
  // @@protoc_insertion_point(field_mutable:calibration.RosbagParams.save_pth)
  return save_pth_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RosbagParams::release_save_pth() {
  // @@protoc_insertion_point(field_release:calibration.RosbagParams.save_pth)
  if (!has_save_pth()) {
    return NULL;
  }
  clear_has_save_pth();
  return save_pth_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RosbagParams::set_allocated_save_pth(::std::string* save_pth) {
  if (save_pth != NULL) {
    set_has_save_pth();
  } else {
    clear_has_save_pth();
  }
  save_pth_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), save_pth);
  // @@protoc_insertion_point(field_set_allocated:calibration.RosbagParams.save_pth)
}

// required string image_topic = 3;
inline bool RosbagParams::has_image_topic() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RosbagParams::set_has_image_topic() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RosbagParams::clear_has_image_topic() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RosbagParams::clear_image_topic() {
  image_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_image_topic();
}
inline const ::std::string& RosbagParams::image_topic() const {
  // @@protoc_insertion_point(field_get:calibration.RosbagParams.image_topic)
  return image_topic_.GetNoArena();
}
inline void RosbagParams::set_image_topic(const ::std::string& value) {
  set_has_image_topic();
  image_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calibration.RosbagParams.image_topic)
}
#if LANG_CXX11
inline void RosbagParams::set_image_topic(::std::string&& value) {
  set_has_image_topic();
  image_topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calibration.RosbagParams.image_topic)
}
#endif
inline void RosbagParams::set_image_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_image_topic();
  image_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calibration.RosbagParams.image_topic)
}
inline void RosbagParams::set_image_topic(const char* value, size_t size) {
  set_has_image_topic();
  image_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calibration.RosbagParams.image_topic)
}
inline ::std::string* RosbagParams::mutable_image_topic() {
  set_has_image_topic();
  // @@protoc_insertion_point(field_mutable:calibration.RosbagParams.image_topic)
  return image_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RosbagParams::release_image_topic() {
  // @@protoc_insertion_point(field_release:calibration.RosbagParams.image_topic)
  if (!has_image_topic()) {
    return NULL;
  }
  clear_has_image_topic();
  return image_topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RosbagParams::set_allocated_image_topic(::std::string* image_topic) {
  if (image_topic != NULL) {
    set_has_image_topic();
  } else {
    clear_has_image_topic();
  }
  image_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image_topic);
  // @@protoc_insertion_point(field_set_allocated:calibration.RosbagParams.image_topic)
}

// required string cloud_topic = 4;
inline bool RosbagParams::has_cloud_topic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RosbagParams::set_has_cloud_topic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RosbagParams::clear_has_cloud_topic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RosbagParams::clear_cloud_topic() {
  cloud_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cloud_topic();
}
inline const ::std::string& RosbagParams::cloud_topic() const {
  // @@protoc_insertion_point(field_get:calibration.RosbagParams.cloud_topic)
  return cloud_topic_.GetNoArena();
}
inline void RosbagParams::set_cloud_topic(const ::std::string& value) {
  set_has_cloud_topic();
  cloud_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calibration.RosbagParams.cloud_topic)
}
#if LANG_CXX11
inline void RosbagParams::set_cloud_topic(::std::string&& value) {
  set_has_cloud_topic();
  cloud_topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calibration.RosbagParams.cloud_topic)
}
#endif
inline void RosbagParams::set_cloud_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cloud_topic();
  cloud_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calibration.RosbagParams.cloud_topic)
}
inline void RosbagParams::set_cloud_topic(const char* value, size_t size) {
  set_has_cloud_topic();
  cloud_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calibration.RosbagParams.cloud_topic)
}
inline ::std::string* RosbagParams::mutable_cloud_topic() {
  set_has_cloud_topic();
  // @@protoc_insertion_point(field_mutable:calibration.RosbagParams.cloud_topic)
  return cloud_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RosbagParams::release_cloud_topic() {
  // @@protoc_insertion_point(field_release:calibration.RosbagParams.cloud_topic)
  if (!has_cloud_topic()) {
    return NULL;
  }
  clear_has_cloud_topic();
  return cloud_topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RosbagParams::set_allocated_cloud_topic(::std::string* cloud_topic) {
  if (cloud_topic != NULL) {
    set_has_cloud_topic();
  } else {
    clear_has_cloud_topic();
  }
  cloud_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cloud_topic);
  // @@protoc_insertion_point(field_set_allocated:calibration.RosbagParams.cloud_topic)
}

// -------------------------------------------------------------------

// LidarCalibParams

// repeated int32 image_size = 1;
inline int LidarCalibParams::image_size_size() const {
  return image_size_.size();
}
inline void LidarCalibParams::clear_image_size() {
  image_size_.Clear();
}
inline ::google::protobuf::int32 LidarCalibParams::image_size(int index) const {
  // @@protoc_insertion_point(field_get:calibration.LidarCalibParams.image_size)
  return image_size_.Get(index);
}
inline void LidarCalibParams::set_image_size(int index, ::google::protobuf::int32 value) {
  image_size_.Set(index, value);
  // @@protoc_insertion_point(field_set:calibration.LidarCalibParams.image_size)
}
inline void LidarCalibParams::add_image_size(::google::protobuf::int32 value) {
  image_size_.Add(value);
  // @@protoc_insertion_point(field_add:calibration.LidarCalibParams.image_size)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LidarCalibParams::image_size() const {
  // @@protoc_insertion_point(field_list:calibration.LidarCalibParams.image_size)
  return image_size_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LidarCalibParams::mutable_image_size() {
  // @@protoc_insertion_point(field_mutable_list:calibration.LidarCalibParams.image_size)
  return &image_size_;
}

// repeated float xyz_range = 2;
inline int LidarCalibParams::xyz_range_size() const {
  return xyz_range_.size();
}
inline void LidarCalibParams::clear_xyz_range() {
  xyz_range_.Clear();
}
inline float LidarCalibParams::xyz_range(int index) const {
  // @@protoc_insertion_point(field_get:calibration.LidarCalibParams.xyz_range)
  return xyz_range_.Get(index);
}
inline void LidarCalibParams::set_xyz_range(int index, float value) {
  xyz_range_.Set(index, value);
  // @@protoc_insertion_point(field_set:calibration.LidarCalibParams.xyz_range)
}
inline void LidarCalibParams::add_xyz_range(float value) {
  xyz_range_.Add(value);
  // @@protoc_insertion_point(field_add:calibration.LidarCalibParams.xyz_range)
}
inline const ::google::protobuf::RepeatedField< float >&
LidarCalibParams::xyz_range() const {
  // @@protoc_insertion_point(field_list:calibration.LidarCalibParams.xyz_range)
  return xyz_range_;
}
inline ::google::protobuf::RepeatedField< float >*
LidarCalibParams::mutable_xyz_range() {
  // @@protoc_insertion_point(field_mutable_list:calibration.LidarCalibParams.xyz_range)
  return &xyz_range_;
}

// required float intensity_threshold = 3;
inline bool LidarCalibParams::has_intensity_threshold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LidarCalibParams::set_has_intensity_threshold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LidarCalibParams::clear_has_intensity_threshold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LidarCalibParams::clear_intensity_threshold() {
  intensity_threshold_ = 0;
  clear_has_intensity_threshold();
}
inline float LidarCalibParams::intensity_threshold() const {
  // @@protoc_insertion_point(field_get:calibration.LidarCalibParams.intensity_threshold)
  return intensity_threshold_;
}
inline void LidarCalibParams::set_intensity_threshold(float value) {
  set_has_intensity_threshold();
  intensity_threshold_ = value;
  // @@protoc_insertion_point(field_set:calibration.LidarCalibParams.intensity_threshold)
}

// required int32 marker_count = 4;
inline bool LidarCalibParams::has_marker_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LidarCalibParams::set_has_marker_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LidarCalibParams::clear_has_marker_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LidarCalibParams::clear_marker_count() {
  marker_count_ = 0;
  clear_has_marker_count();
}
inline ::google::protobuf::int32 LidarCalibParams::marker_count() const {
  // @@protoc_insertion_point(field_get:calibration.LidarCalibParams.marker_count)
  return marker_count_;
}
inline void LidarCalibParams::set_marker_count(::google::protobuf::int32 value) {
  set_has_marker_count();
  marker_count_ = value;
  // @@protoc_insertion_point(field_set:calibration.LidarCalibParams.marker_count)
}

// required bool use_camera_info = 5;
inline bool LidarCalibParams::has_use_camera_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LidarCalibParams::set_has_use_camera_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LidarCalibParams::clear_has_use_camera_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LidarCalibParams::clear_use_camera_info() {
  use_camera_info_ = false;
  clear_has_use_camera_info();
}
inline bool LidarCalibParams::use_camera_info() const {
  // @@protoc_insertion_point(field_get:calibration.LidarCalibParams.use_camera_info)
  return use_camera_info_;
}
inline void LidarCalibParams::set_use_camera_info(bool value) {
  set_has_use_camera_info();
  use_camera_info_ = value;
  // @@protoc_insertion_point(field_set:calibration.LidarCalibParams.use_camera_info)
}

// repeated float project_matrix = 6;
inline int LidarCalibParams::project_matrix_size() const {
  return project_matrix_.size();
}
inline void LidarCalibParams::clear_project_matrix() {
  project_matrix_.Clear();
}
inline float LidarCalibParams::project_matrix(int index) const {
  // @@protoc_insertion_point(field_get:calibration.LidarCalibParams.project_matrix)
  return project_matrix_.Get(index);
}
inline void LidarCalibParams::set_project_matrix(int index, float value) {
  project_matrix_.Set(index, value);
  // @@protoc_insertion_point(field_set:calibration.LidarCalibParams.project_matrix)
}
inline void LidarCalibParams::add_project_matrix(float value) {
  project_matrix_.Add(value);
  // @@protoc_insertion_point(field_add:calibration.LidarCalibParams.project_matrix)
}
inline const ::google::protobuf::RepeatedField< float >&
LidarCalibParams::project_matrix() const {
  // @@protoc_insertion_point(field_list:calibration.LidarCalibParams.project_matrix)
  return project_matrix_;
}
inline ::google::protobuf::RepeatedField< float >*
LidarCalibParams::mutable_project_matrix() {
  // @@protoc_insertion_point(field_mutable_list:calibration.LidarCalibParams.project_matrix)
  return &project_matrix_;
}

// required int32 iteration_count = 7;
inline bool LidarCalibParams::has_iteration_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LidarCalibParams::set_has_iteration_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LidarCalibParams::clear_has_iteration_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LidarCalibParams::clear_iteration_count() {
  iteration_count_ = 0;
  clear_has_iteration_count();
}
inline ::google::protobuf::int32 LidarCalibParams::iteration_count() const {
  // @@protoc_insertion_point(field_get:calibration.LidarCalibParams.iteration_count)
  return iteration_count_;
}
inline void LidarCalibParams::set_iteration_count(::google::protobuf::int32 value) {
  set_has_iteration_count();
  iteration_count_ = value;
  // @@protoc_insertion_point(field_set:calibration.LidarCalibParams.iteration_count)
}

// repeated float lidar_init_rot = 8;
inline int LidarCalibParams::lidar_init_rot_size() const {
  return lidar_init_rot_.size();
}
inline void LidarCalibParams::clear_lidar_init_rot() {
  lidar_init_rot_.Clear();
}
inline float LidarCalibParams::lidar_init_rot(int index) const {
  // @@protoc_insertion_point(field_get:calibration.LidarCalibParams.lidar_init_rot)
  return lidar_init_rot_.Get(index);
}
inline void LidarCalibParams::set_lidar_init_rot(int index, float value) {
  lidar_init_rot_.Set(index, value);
  // @@protoc_insertion_point(field_set:calibration.LidarCalibParams.lidar_init_rot)
}
inline void LidarCalibParams::add_lidar_init_rot(float value) {
  lidar_init_rot_.Add(value);
  // @@protoc_insertion_point(field_add:calibration.LidarCalibParams.lidar_init_rot)
}
inline const ::google::protobuf::RepeatedField< float >&
LidarCalibParams::lidar_init_rot() const {
  // @@protoc_insertion_point(field_list:calibration.LidarCalibParams.lidar_init_rot)
  return lidar_init_rot_;
}
inline ::google::protobuf::RepeatedField< float >*
LidarCalibParams::mutable_lidar_init_rot() {
  // @@protoc_insertion_point(field_mutable_list:calibration.LidarCalibParams.lidar_init_rot)
  return &lidar_init_rot_;
}

// repeated float lidar_origin = 9;
inline int LidarCalibParams::lidar_origin_size() const {
  return lidar_origin_.size();
}
inline void LidarCalibParams::clear_lidar_origin() {
  lidar_origin_.Clear();
}
inline float LidarCalibParams::lidar_origin(int index) const {
  // @@protoc_insertion_point(field_get:calibration.LidarCalibParams.lidar_origin)
  return lidar_origin_.Get(index);
}
inline void LidarCalibParams::set_lidar_origin(int index, float value) {
  lidar_origin_.Set(index, value);
  // @@protoc_insertion_point(field_set:calibration.LidarCalibParams.lidar_origin)
}
inline void LidarCalibParams::add_lidar_origin(float value) {
  lidar_origin_.Add(value);
  // @@protoc_insertion_point(field_add:calibration.LidarCalibParams.lidar_origin)
}
inline const ::google::protobuf::RepeatedField< float >&
LidarCalibParams::lidar_origin() const {
  // @@protoc_insertion_point(field_list:calibration.LidarCalibParams.lidar_origin)
  return lidar_origin_;
}
inline ::google::protobuf::RepeatedField< float >*
LidarCalibParams::mutable_lidar_origin() {
  // @@protoc_insertion_point(field_mutable_list:calibration.LidarCalibParams.lidar_origin)
  return &lidar_origin_;
}

// -------------------------------------------------------------------

// CameraCalibParams

// required string camera_config_path = 1;
inline bool CameraCalibParams::has_camera_config_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraCalibParams::set_has_camera_config_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraCalibParams::clear_has_camera_config_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraCalibParams::clear_camera_config_path() {
  camera_config_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_camera_config_path();
}
inline const ::std::string& CameraCalibParams::camera_config_path() const {
  // @@protoc_insertion_point(field_get:calibration.CameraCalibParams.camera_config_path)
  return camera_config_path_.GetNoArena();
}
inline void CameraCalibParams::set_camera_config_path(const ::std::string& value) {
  set_has_camera_config_path();
  camera_config_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:calibration.CameraCalibParams.camera_config_path)
}
#if LANG_CXX11
inline void CameraCalibParams::set_camera_config_path(::std::string&& value) {
  set_has_camera_config_path();
  camera_config_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:calibration.CameraCalibParams.camera_config_path)
}
#endif
inline void CameraCalibParams::set_camera_config_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_camera_config_path();
  camera_config_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:calibration.CameraCalibParams.camera_config_path)
}
inline void CameraCalibParams::set_camera_config_path(const char* value, size_t size) {
  set_has_camera_config_path();
  camera_config_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:calibration.CameraCalibParams.camera_config_path)
}
inline ::std::string* CameraCalibParams::mutable_camera_config_path() {
  set_has_camera_config_path();
  // @@protoc_insertion_point(field_mutable:calibration.CameraCalibParams.camera_config_path)
  return camera_config_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CameraCalibParams::release_camera_config_path() {
  // @@protoc_insertion_point(field_release:calibration.CameraCalibParams.camera_config_path)
  if (!has_camera_config_path()) {
    return NULL;
  }
  clear_has_camera_config_path();
  return camera_config_path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CameraCalibParams::set_allocated_camera_config_path(::std::string* camera_config_path) {
  if (camera_config_path != NULL) {
    set_has_camera_config_path();
  } else {
    clear_has_camera_config_path();
  }
  camera_config_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), camera_config_path);
  // @@protoc_insertion_point(field_set_allocated:calibration.CameraCalibParams.camera_config_path)
}

// -------------------------------------------------------------------

// MarkerBoardParmas

// required int32 marker_number = 1;
inline bool MarkerBoardParmas::has_marker_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarkerBoardParmas::set_has_marker_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarkerBoardParmas::clear_has_marker_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarkerBoardParmas::clear_marker_number() {
  marker_number_ = 0;
  clear_has_marker_number();
}
inline ::google::protobuf::int32 MarkerBoardParmas::marker_number() const {
  // @@protoc_insertion_point(field_get:calibration.MarkerBoardParmas.marker_number)
  return marker_number_;
}
inline void MarkerBoardParmas::set_marker_number(::google::protobuf::int32 value) {
  set_has_marker_number();
  marker_number_ = value;
  // @@protoc_insertion_point(field_set:calibration.MarkerBoardParmas.marker_number)
}

// required float board_length_e1 = 2;
inline bool MarkerBoardParmas::has_board_length_e1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarkerBoardParmas::set_has_board_length_e1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarkerBoardParmas::clear_has_board_length_e1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarkerBoardParmas::clear_board_length_e1() {
  board_length_e1_ = 0;
  clear_has_board_length_e1();
}
inline float MarkerBoardParmas::board_length_e1() const {
  // @@protoc_insertion_point(field_get:calibration.MarkerBoardParmas.board_length_e1)
  return board_length_e1_;
}
inline void MarkerBoardParmas::set_board_length_e1(float value) {
  set_has_board_length_e1();
  board_length_e1_ = value;
  // @@protoc_insertion_point(field_set:calibration.MarkerBoardParmas.board_length_e1)
}

// required float board_length_e2 = 3;
inline bool MarkerBoardParmas::has_board_length_e2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarkerBoardParmas::set_has_board_length_e2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarkerBoardParmas::clear_has_board_length_e2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarkerBoardParmas::clear_board_length_e2() {
  board_length_e2_ = 0;
  clear_has_board_length_e2();
}
inline float MarkerBoardParmas::board_length_e2() const {
  // @@protoc_insertion_point(field_get:calibration.MarkerBoardParmas.board_length_e2)
  return board_length_e2_;
}
inline void MarkerBoardParmas::set_board_length_e2(float value) {
  set_has_board_length_e2();
  board_length_e2_ = value;
  // @@protoc_insertion_point(field_set:calibration.MarkerBoardParmas.board_length_e2)
}

// required float board_length_b1 = 4;
inline bool MarkerBoardParmas::has_board_length_b1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarkerBoardParmas::set_has_board_length_b1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarkerBoardParmas::clear_has_board_length_b1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarkerBoardParmas::clear_board_length_b1() {
  board_length_b1_ = 0;
  clear_has_board_length_b1();
}
inline float MarkerBoardParmas::board_length_b1() const {
  // @@protoc_insertion_point(field_get:calibration.MarkerBoardParmas.board_length_b1)
  return board_length_b1_;
}
inline void MarkerBoardParmas::set_board_length_b1(float value) {
  set_has_board_length_b1();
  board_length_b1_ = value;
  // @@protoc_insertion_point(field_set:calibration.MarkerBoardParmas.board_length_b1)
}

// required float board_length_b2 = 5;
inline bool MarkerBoardParmas::has_board_length_b2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarkerBoardParmas::set_has_board_length_b2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarkerBoardParmas::clear_has_board_length_b2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarkerBoardParmas::clear_board_length_b2() {
  board_length_b2_ = 0;
  clear_has_board_length_b2();
}
inline float MarkerBoardParmas::board_length_b2() const {
  // @@protoc_insertion_point(field_get:calibration.MarkerBoardParmas.board_length_b2)
  return board_length_b2_;
}
inline void MarkerBoardParmas::set_board_length_b2(float value) {
  set_has_board_length_b2();
  board_length_b2_ = value;
  // @@protoc_insertion_point(field_set:calibration.MarkerBoardParmas.board_length_b2)
}

// required float marker_length = 6;
inline bool MarkerBoardParmas::has_marker_length() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarkerBoardParmas::set_has_marker_length() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarkerBoardParmas::clear_has_marker_length() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarkerBoardParmas::clear_marker_length() {
  marker_length_ = 0;
  clear_has_marker_length();
}
inline float MarkerBoardParmas::marker_length() const {
  // @@protoc_insertion_point(field_get:calibration.MarkerBoardParmas.marker_length)
  return marker_length_;
}
inline void MarkerBoardParmas::set_marker_length(float value) {
  set_has_marker_length();
  marker_length_ = value;
  // @@protoc_insertion_point(field_set:calibration.MarkerBoardParmas.marker_length)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace calibration

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_calibration_2eproto
